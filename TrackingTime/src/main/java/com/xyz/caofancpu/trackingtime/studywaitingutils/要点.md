- 能干活

- Java基础

- 最好熟悉分布式框架

框架SSM, 痛点






  - 缓存穿透:

    - 定义

      ```textile
      因查询一个在缓存中一定不存在的数据(KEY), 从而导致每次都到DB进行查询, 大流量下压倒数据库
      ```

    - 解决方案

      ```text
      1.布隆过滤器
      2.首次在DB查询的空结果写入Redis做缓存, 设置过期时间,例如3-5分钟
      ```

      

  - 缓存雪崩

    - 定义

      ```text
      大量缓存的数据设置了相同的过期时间,导致在某一时刻大量缓存数据同时失效, 压倒后端数据库
      ```

    - 解决方案

      ```text
      将缓存失效时间分散开, 在原有失效时间基础上增加一个随机值, 1-5分钟随机
      ```

  - 缓存击穿

    - 定义

      ```text
      某个热点数据key在某一时刻过期, 导致该热点数据高频访问被引到后端, 压垮数据库
      ```

    - 解决方案

      ```text
      思路: 使用尽量少的线程(最好是一个)构建缓存, 其他线程等待构建缓存执行完毕后, 重新从缓存获取数据
      
      1.使用分布式锁构建缓存, 一个线程构建缓存, 其余线程阻塞等待缓存构建完毕
      2.热点数据物理上永不过期, 将热点数据的过期时间设置较大并存入对应value中,
        读取后发现快要过期时, 通过异步线程更新缓存
      ```

      

- 线程池





- 线程同步

  - Semaphore信号量, 用于限流

  - CountDownLatch用于倒计时等待或并行数据请求, 主线程等到子线程任务执行完后再将结果汇总

  - CyclicBarrier用于裁判或公交, 统一发车, 先来的等待, 且可在发车前执行一个任务

  - Exchanger用于线程交换数据, 注意线程一定要成对


























































