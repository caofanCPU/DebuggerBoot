

- 常量缓存，方便转换

对象内容

- 对象头: hashCode，GC分代年龄，锁的状态(无锁-偏向锁-轻量级锁-重量级锁)

ReentrantLock源码结构

线程池是如何控制核心线程数的

- 线程池工作流程
- 新建线程会判断，回收线程也会判断
- 线程池核心参数，核心线程数，最大线程数，阻塞队列大小
- 阻塞队列重要特点，添加任务时full锁，满了就阻塞put操作，获取任务时empty锁，空了阻塞take操作


MySQL：

MySQL主键和索引的区别，索引搜索的复杂度

MySQL事务级别

- MySQL默认隔离级别
- 原有数据5, 6, 7
- 线程A开始事务，select * from table
- 线程B开始事务, 等A查询第一次后再插入数据8
- 线程A 再查数据，select * from table
- 线程B再查数据，select * from table

MySQL单个事务内的行为

MySQL脏读、不可重复读、幻读，MVCC，事务ID+版本号

MySQL慢sql优化方式, explain内容 遇到%like%那就得全文索引, -> ES

Kafka与RocketMQ的区别, 如何扩展 MySQL与HBase的区别

接口慢, 如何解决: 加缓存, 缓存预热 -> 核心思路: 同步转异步

设计模式: 模板模式, 单例模式

项目管理上的: 如何保证测试用例, 如何保证代码质量

Redis:

用的集群:

- 16384, CRC16位运算, 2的14次方, 集群中节点都会负责一部分插槽区域, 该数据是一个bitmap, 14次方大概10+3+1, 2KB, 如果用16那就是8KB, 节省带宽 而且一般集群节点不会超过1000个
- 主从集群, 高可用，但是存在主从延时, 哪怕先写主库再写从库再返回, 也会出现数据不一致, 于是引入Raft一致性协议, 主要是全局唯一递增的序列号, 并且操作日志消息还会有一个提交状态, 超过半数的从节点写入成功才算写入完成, 消息才置为已提交, 才对客户端可见 当发生主从切换时, 数据仍然保持一致, 前一时刻大部分节点数据都统一的结果是真正的结果, 主库新写的是无效的客户端也不可见, 少部分的序列号较小, 不会竞选为master, 之后再同步

对于一个过期的Key，redis是如何处理的

缓存大量数据，有啥方法

pipeline和普通命令的区别

SUAN-F**K

