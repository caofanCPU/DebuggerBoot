Java自动装箱拆箱原理

- 常量缓存，方便转换

对象内容

- 对象头: hashCode，GC分代年龄，锁的状态(无锁-偏向锁-轻量级锁-重量级锁)

ReentrantLock源码结构

线程池是如何控制核心线程数的

- 线程池工作流程
- 新建线程会判断，回收线程也会判断
- 线程池核心参数，核心线程数，最大线程数，阻塞队列大小
- 阻塞队列重要特点，添加任务时full锁，满了就阻塞put操作，获取任务时empty锁，空了阻塞take操作


MySQL：

MySQL主键和索引的区别，索引搜索的复杂度

MySQL事务级别

- MySQL默认隔离级别
- 原有数据5, 6, 7
- 线程A开始事务，select * from table
- 线程B开始事务, 等A查询第一次后再插入数据8
- 线程A 再查数据，select * from table
- 线程B再查数据，select * from table

MySQL单个事务内的行为

MySQL脏读、不可重复读、幻读，MVCC，事务ID+版本号

MySQL慢sql优化方式, explain内容 遇到%like%那就得全文索引, -> ES

Kafka与RocketMQ的区别, 如何扩展 MySQL与HBase的区别

接口慢, 如何解决: 加缓存, 缓存预热 -> 核心思路: 同步转异步

设计模式: 模板模式, 单例模式

项目管理上的: 如何保证测试用例, 如何保证代码质量

Redis:

用的集群:

- 16384, CRC16位运算, 2的14次方, 集群中节点都会负责一部分插槽区域, 该数据是一个bitmap, 14次方大概10+3+1, 2KB, 如果用16那就是8KB, 节省带宽 而且一般集群节点不会超过1000个
- 主从集群, 高可用，但是存在主从延时, 哪怕先写主库再写从库再返回, 也会出现数据不一致, 于是引入Raft一致性协议, 主要是全局唯一递增的序列号, 并且操作日志消息还会有一个提交状态, 超过半数的从节点写入成功才算写入完成, 消息才置为已提交, 才对客户端可见 当发生主从切换时, 数据仍然保持一致, 前一时刻大部分节点数据都统一的结果是真正的结果, 主库新写的是无效的客户端也不可见, 少部分的序列号较小, 不会竞选为master, 之后再同步

对于一个过期的Key，redis是如何处理的

缓存大量数据，有啥方法

pipeline和普通命令的区别

SUAN-F**K

- [二叉树中最大路径和](https://blog.csdn.net/qq_15764477/article/details/106882100)
  - 递归
  - 考虑子树, 最大路径就4种, root| root+left| root+right| root+left+right
- [nlogn时间和常数级空间链表排序](https://www.jianshu.com/p/030a59528323)
  - 归并排序
- [无序数组最大上升子序列长度](https://www.freesion.com/article/71831322689/)
- [两个超大整型字符串相加]()
  1. 字符串拼接, 长字符串长度作为分解符
  2. 遍历拼接后的字符串, 倒序遍历长字符串, 推算短字符串索引
  3. 计算元素数值, 考虑来自低位的进位
  4. 写入结果int[] result, 结果是长字符串长度+1
  5. 如果最后的进位为非0, 那么result[0]赋值
  6. 输出时判断result[0]是否为0, 不为0才输出
- 验证二叉搜索树
- 给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表
  - 参考两字符串相加
- 返回一个树的左视图
- 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先
- 求一个环形链表的环的长度
- 一个环上有10个点,编号为0-9,从0点出发,每步可以顺时针到下一个点,也可以逆时针到上一个点,求:经过n步又回到0点有多少种不同的走法
  - 环球旅行, 动态规划table(step)(index) = table(step-1)((index+1+n)%n) + table(step-1)((index-1+n)%n)
- 找出所有相加之和为 n 的 k 个数的组合，组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字
  - BitMap
- 最长不重复的连续子串
  - 滑动窗口
- 判断一个树是否是平衡二叉树
- 给定一个长度为N的整形数组arr，其中有N个互不相等的自然数1-N，请实现arr的排序，但是不要把下标0∼N−1位置上的数通过直接赋值的方式替换成1∼N
  - SOS
- 对于一个字符串，计算其中最长回文子串的长度
  1. 一般为n^2, 将字符串翻转, 得到两个字符串, 就可以利用两个字符串最长公共子串解决了
  2. Manacher算法可以到n
- 对于两个字符串, 计算最长公共子串
  1. 动态规划
  2. n^2