package com.xyz.caofancpu.service.impl;


import com.alibaba.fastjson.JSONObject;
import com.xyz.caofancpu.model.Attachment;
import com.xyz.caofancpu.service.CommonOperateService;
import com.xyz.caofancpu.util.commonOperateUtils.GlobalResultCheckUtil;
import com.xyz.caofancpu.util.dataOperateUtils.DateUtil;
import com.xyz.caofancpu.util.result.CustomerErrorInfo;
import com.xyz.caofancpu.util.result.GlobalErrorInfoException;
import com.xyz.caofancpu.util.result.ResultBody;
import com.xyz.caofancpu.utils.RestTemplateUtil;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.DependsOn;
import org.springframework.stereotype.Service;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.multipart.MultipartFile;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.util.*;


/**
 * ServiceImpl CommonOperate
 * This code is generated by the Hen, strongly recommended not to modify directly.
 */
@Service("commonOperateService")
@DependsOn("initContextPropertyInitializer")
public class CommonOperateServiceImpl implements CommonOperateService {
    
    /**
     * LOG
     */
    private static final Logger logger = LoggerFactory.getLogger(CommonOperateServiceImpl.class);
    
    private static final String COMMA_SEPARATOR = ",";
    
    @Value("${app.name}")
    private String appName;
    
    @Value("${file.url}")
    private String fileAccessUrl;
    
    @Value("${swagger.authorizationKey}")
    private String authKey;
    
    @Value("${fileOperate.logging.key}")
    private String fileOperateLoggingKey;
    
    @Value("${fileOperate.logging.value}")
    private String fileOperateLoggingValue;
    
    @Resource
    private transient RestTemplateUtil restTemplateUtil;
    
    @Override
    public void uploadAttachment(Attachment attachment, MultipartFile file)
            throws GlobalErrorInfoException {
        if (Objects.isNull(file) || file.isEmpty()) {
            throw new GlobalErrorInfoException(new CustomerErrorInfo("上传文件不能为空!"));
        }
        byte[] bytes;
        try {
            bytes = file.getBytes();
        } catch (IOException e) {
            logger.error("获取文件二进制流失败, {}", e.getMessage());
            throw new GlobalErrorInfoException(new CustomerErrorInfo("文件上传失败, 请重试!"));
        }
        
        String originalFilename = file.getOriginalFilename().toLowerCase();
        String type = originalFilename.substring(originalFilename.lastIndexOf("."));
        // 上传服务器开始
        String path = UUID.randomUUID().toString().replaceAll("-", "") + type;
        String fileBase64 = Base64.getEncoder().encodeToString(bytes);
        Map<String, Object> paramMap = new HashMap<String, Object>(8, 0.75f) {
            {
                put("appname", appName);
                put("filename", path);
                put("contents", fileBase64);
                put("open", false);
            }
        };
        // 禁用文件内容打印LOG
        closeFileOperateLogging(paramMap);
        restTemplateUtil.postBody(fileAccessUrl + "/file/upload", paramMap);
        
        attachment.setType(type);
        attachment.setName(path);
        attachment.setCreateTime(DateUtil.date2StrForSimpleDetail(new Date()));
        
        logger.info("\n客户端于[{}]上传文件：[{}]", attachment.getCreateTime(), attachment.getName());
    }
    
    @Override
    public String getAttachmentAccessUrl(String attachmentName)
            throws GlobalErrorInfoException {
        if (StringUtils.isBlank(attachmentName)) {
            throw new GlobalErrorInfoException(new CustomerErrorInfo("文件名参数错误"));
        }
        Map<String, Object> map = new HashMap<String, Object>(4, 0.5f) {
            {
                put("appname", appName);
                put("filename", attachmentName);
            }
        };
        
        ResultBody resultBody = restTemplateUtil.postBody(fileAccessUrl + "/file/generateUrl", map);
        GlobalResultCheckUtil.handleMSResultBody(resultBody);
        JSONObject jsonObject = JSONObject.parseObject(JSONObject.toJSONString(resultBody));
        String accessUrl = jsonObject.getString("data");
        logger.info("查询文件访问Url:\n输入文件名[{}]\n输出Url[{}]", attachmentName, accessUrl);
        return accessUrl;
    }
    
    @Override
    public String loadToken() {
        RequestAttributes temRequestAttributes = RequestContextHolder.getRequestAttributes();
        if (Objects.isNull(temRequestAttributes)) {
            return null;
        }
        ServletRequestAttributes sra = (ServletRequestAttributes) temRequestAttributes;
        RequestContextHolder.setRequestAttributes(sra, true);
        HttpServletRequest request;
        try {
            request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        } catch (Exception e) {
            logger.info("[提示]无HttpServletRequest信息, 加载token为null");
            return null;
        }
        if (Objects.isNull(request)) {
            return null;
        }
        String token = request.getHeader(authKey);
        return token;
    }
    
    @Override
    public void closeFileOperateLogging(Map<String, Object> paramMap) {
        if (Objects.isNull(paramMap)) {
            return;
        }
        paramMap.put(fileOperateLoggingKey, fileOperateLoggingValue);
    }
    
}

